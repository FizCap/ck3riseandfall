##################################################
# Rise and Fall — Puppet Master scripted effects
# NOTE: Placeholder math/tokens; adjust to your mod's canonical script_values and effects

# Steal 50% of liege short-term gold and give it to diarch
riseandfall_steal_gold_effect = {
	# actor = diarch, recipient = liege
	# Based on palace coup gold transfer
	scope:recipient = {
		# Initialize the transfer amount so change_variable always operates on a value variable
		set_variable = { name = rf_transfer_gold value = 0 }
		# If the liege has gold, set the transfer amount to their gold first
		if = { limit = { gold > 1 } set_variable = { name = rf_transfer_gold value = gold } }
		# Use integer math: divide by 2 to transfer roughly 50%
		if = { limit = { var:rf_transfer_gold > 0 } change_variable = { name = rf_transfer_gold divide = 2 } }
	}
	# Give to diarch
	if = { limit = { scope:recipient = { has_variable = rf_transfer_gold } scope:recipient = { var:rf_transfer_gold > 0 } } scope:actor = { add_short_term_gold = scope:recipient.var:rf_transfer_gold } }
	# Remove from liege
	scope:recipient = {
		if = { limit = { var:rf_transfer_gold > 0 } remove_short_term_gold = var:rf_transfer_gold }
		remove_variable = rf_transfer_gold
	}
	# Add cooldown
	scope:recipient = { set_variable = { name = puppet_master_cooldown value = yes days = 365 } }
}

# When a guest arrives at a court, ensure a visiting puppet master (diarch)
# who is a foreign guest (not already a courtier) becomes employed by the host
# so they are treated as a courtier in that court.
# Expected invocation context: root = guest, host = host
riseandfall_set_guest_puppet_master_employer_se = {
	# Run in the guest scope (root)
	root = {
		if = {
			limit = {
				# Is the root character the active diarch of the host?
				is_diarch_of_target = scope:host
				# Is the root a foreign court guest of the host (they have a liege)
				is_foreign_court_guest_of = scope:host
				# Make sure they are not already a courtier of the host
				NOT = { is_courtier_of = scope:host }
			}
			# Move the guest into the host's court (set them as employed by the host)
			set_employer = scope:host
		}
	}
}

# Grant a strong hook on the liege to the diarch
riseandfall_curry_favor_effect = {
	# Give the actor a strong favor hook on the recipient
	scope:actor = {
		add_hook = {
			target = scope:recipient
			type = strong_favor_hook
		}
	}
	# Add cooldown on the recipient (so the liege cannot be targeted again immediately)
	scope:recipient = { set_variable = { name = puppet_master_cooldown value = yes days = 365 } }
}

# Transfer all titles from liege to diarch (violent usurpation)
riseandfall_overthrow_liege_effect = {
	# Based on palace coup overthrow
	create_title_and_vassal_change = {
		type = conquest
		save_scope_as = change
	}
	# Transfer all held titles from recipient to actor
	scope:recipient = {
        # If the recipient has a capital county, transfer that county first
        if = {
            limit = { scope:recipient = { capital_county = { exists = yes } } }
            scope:recipient = {
                capital_county = {
                    change_title_holder = {
                        holder = scope:actor
                        change = scope:change
                        take_baronies = yes
                    }
                }
            }
        }
		every_held_title = {
			limit = {
				holder = scope:recipient
				# Avoid changing barony-level titles directly (engine requires changing the county instead)
				NOT = { tier = tier_barony }
				NOT = { is_head_of_faith = yes }
				NOT = { is_noble_family_title = yes }
			}
			change_title_holder = {
				holder = scope:actor
				change = scope:change
				take_baronies = yes
			}
		}
	}
	resolve_title_and_vassal_change = scope:change
	# Add cooldown
	scope:recipient = { set_variable = { name = puppet_master_cooldown value = yes days = 365 } }
}

# Force liege to abdicate by transferring their titles to a chosen successor (youngest unlanded child; fallback to dynasty in court)
riseandfall_force_abdicate_effect = {
	# Create the title change scope used by change_title_holder calls
	create_title_and_vassal_change = {
		type = conquest
		save_scope_as = change
	}

	scope:recipient = {
		# initialize a big age to find the youngest
		set_variable = { name = rf_candidate_best_age value = 999 }
		# Choose candidate depending on realm succession law: prefer males/females per law settings
		if = {
			limit = { scope:recipient = { has_realm_law = male_only_law } }
			# Male-only: pick youngest unlanded male child
			every_close_or_extended_family_member = {
				limit = {
					is_landed = no
					NOT = { is_adult = yes }
					is_male = yes
					OR = {
						employer = scope:recipient
						liege = scope:recipient
						top_liege = scope:recipient
					}
				}
				set_variable = { name = candidate_age value = age }
				save_scope_as = candidate_for_score
				scope:recipient = { set_variable = { name = tmp_candidate_age value = scope:candidate_for_score.var:candidate_age } }
				if = {
					limit = { scope:recipient = { has_variable = tmp_candidate_age has_variable = rf_candidate_best_age var:tmp_candidate_age < var:rf_candidate_best_age } }
					save_scope_as = chosen_successor
					scope:recipient = { set_variable = { name = rf_candidate_best_age value = scope:recipient.var:tmp_candidate_age } }
				}
			}
		}
		else_if = {
			limit = { scope:recipient = { has_realm_law = male_preference_law } }
			# Male-preference: try youngest males first, then females if none found
			# First pass: males
			every_close_or_extended_family_member = {
				limit = {
					is_landed = no
					NOT = { is_adult = yes }
					is_male = yes
					OR = {
						employer = scope:recipient
						liege = scope:recipient
						top_liege = scope:recipient
					}
				}
				set_variable = { name = candidate_age value = age }
				save_scope_as = candidate_for_score
				scope:recipient = { set_variable = { name = tmp_candidate_age value = scope:candidate_for_score.var:candidate_age } }
				if = {
					limit = { scope:recipient = { has_variable = tmp_candidate_age has_variable = rf_candidate_best_age var:tmp_candidate_age < var:rf_candidate_best_age } }
					save_scope_as = chosen_successor
					scope:recipient = { set_variable = { name = rf_candidate_best_age value = scope:recipient.var:tmp_candidate_age } }
				}
			}
			# If no male chosen, try females
			if = {
				limit = { NOT = { exists = scope:chosen_successor } }
				scope:recipient = { set_variable = { name = rf_candidate_best_age value = 999 } }
				every_close_or_extended_family_member = {
					limit = {
						is_landed = no
						NOT = { is_adult = yes }
						is_male = no
						OR = {
							employer = scope:recipient
							liege = scope:recipient
							top_liege = scope:recipient
						}
					}
					set_variable = { name = candidate_age value = age }
					save_scope_as = candidate_for_score
					scope:recipient = { set_variable = { name = tmp_candidate_age value = scope:candidate_for_score.var:candidate_age } }
					if = {
						limit = { scope:recipient = { has_variable = tmp_candidate_age has_variable = rf_candidate_best_age var:tmp_candidate_age < var:rf_candidate_best_age } }
						save_scope_as = chosen_successor
						scope:recipient = { set_variable = { name = rf_candidate_best_age value = scope:recipient.var:tmp_candidate_age } }
					}
				}
			}
		}
		else_if = {
			limit = { scope:recipient = { has_realm_law = female_preference_law } }
			# Female-preference: try youngest females first, then males if none found
			# First pass: females
			every_close_or_extended_family_member = {
				limit = {
					is_landed = no
					NOT = { is_adult = yes }
					is_male = no
					OR = {
						employer = scope:recipient
						liege = scope:recipient
						top_liege = scope:recipient
					}
				}
				set_variable = { name = candidate_age value = age }
				save_scope_as = candidate_for_score
				scope:recipient = { set_variable = { name = tmp_candidate_age value = scope:candidate_for_score.var:candidate_age } }
				if = {
					limit = { scope:recipient = { has_variable = tmp_candidate_age has_variable = rf_candidate_best_age var:tmp_candidate_age < var:rf_candidate_best_age } }
					save_scope_as = chosen_successor
					scope:recipient = { set_variable = { name = rf_candidate_best_age value = scope:recipient.var:tmp_candidate_age } }
				}
			}
			# If no female chosen, try males
			if = {
				limit = { NOT = { exists = scope:chosen_successor } }
				scope:recipient = { set_variable = { name = rf_candidate_best_age value = 999 } }
				every_close_or_extended_family_member = {
					limit = {
						is_landed = no
						NOT = { is_adult = yes }
						is_male = yes
						OR = {
							employer = scope:recipient
							liege = scope:recipient
							top_liege = scope:recipient
						}
					}
					set_variable = { name = candidate_age value = age }
					save_scope_as = candidate_for_score
					scope:recipient = { set_variable = { name = tmp_candidate_age value = scope:candidate_for_score.var:candidate_age } }
					if = {
						limit = { scope:recipient = { has_variable = tmp_candidate_age has_variable = rf_candidate_best_age var:tmp_candidate_age < var:rf_candidate_best_age } }
						save_scope_as = chosen_successor
						scope:recipient = { set_variable = { name = rf_candidate_best_age value = scope:recipient.var:tmp_candidate_age } }
					}
				}
			}
		}
		else_if = {
			limit = { scope:recipient = { has_realm_law = female_only_law } }
			# Female-only: pick youngest unlanded female child
			every_close_or_extended_family_member = {
				limit = {
					is_landed = no
					NOT = { is_adult = yes }
					is_male = no
					OR = {
						employer = scope:recipient
						liege = scope:recipient
						top_liege = scope:recipient
					}
				}
				set_variable = { name = candidate_age value = age }
				save_scope_as = candidate_for_score
				scope:recipient = { set_variable = { name = tmp_candidate_age value = scope:candidate_for_score.var:candidate_age } }
				if = {
					limit = { scope:recipient = { has_variable = tmp_candidate_age has_variable = rf_candidate_best_age var:tmp_candidate_age < var:rf_candidate_best_age } }
					save_scope_as = chosen_successor
					scope:recipient = { set_variable = { name = rf_candidate_best_age value = scope:recipient.var:tmp_candidate_age } }
				}
			}
		}
		else = {
			# Default: any gender allowed (equal succession or unspecified)
			every_close_or_extended_family_member = {
				limit = {
					is_landed = no
					NOT = { is_adult = yes }
					OR = {
						employer = scope:recipient
						liege = scope:recipient
						top_liege = scope:recipient
					}
				}
				set_variable = { name = candidate_age value = age }
				save_scope_as = candidate_for_score
				scope:recipient = { set_variable = { name = tmp_candidate_age value = scope:candidate_for_score.var:candidate_age } }
				if = {
					limit = { scope:recipient = { has_variable = tmp_candidate_age has_variable = rf_candidate_best_age var:tmp_candidate_age < var:rf_candidate_best_age } }
					save_scope_as = chosen_successor
					scope:recipient = { set_variable = { name = rf_candidate_best_age value = scope:recipient.var:tmp_candidate_age } }
				}
			}
		}

		# If we did not find an unlanded child, fallback to dynasty members in the recipient's court (pick the first valid adult member)
		if = {
			limit = { NOT = { exists = scope:chosen_successor } scope:recipient = { has_dynasty = yes } }
			scope:recipient = {
				dynasty = {
					every_dynasty_member = {
						# Save the current dynasty member as a temporary candidate
						save_scope_as = candidate_for_score
						# Ensure the candidate is an adult, not a ruler, and present in the recipient's court
						if = {
							limit = { is_adult = yes NOT = { is_ruler = yes } scope:recipient = { any_courtier = { this = scope:candidate_for_score } } }
							# pick the first valid candidate
							save_scope_as = chosen_successor
						}
					}
				}
			}
		}

		# If we still have no candidate, abort the effect gracefully
		if = {
			limit = { exists = scope:chosen_successor }
			# proceed to transfer all held titles from recipient to chosen_successor
			every_held_title = {
				limit = {
					holder = scope:recipient
					# Avoid changing barony-level titles directly (engine requires changing the county instead)
					NOT = { tier = tier_barony }
					NOT = { is_head_of_faith = yes }
					NOT = { is_noble_family_title = yes }
				}
				change_title_holder = {
					holder = scope:chosen_successor
					change = scope:change
					take_baronies = no
				}
			}
			resolve_title_and_vassal_change = scope:change
			# Add cooldown on the recipient to prevent immediate re-uses
			scope:recipient = { set_variable = { name = puppet_master_cooldown value = yes days = 365 } }

			# Re-establish puppet regency on the new liege so the puppet master stays in power
			# (make the actor the diarch of the chosen_successor and set the puppet_regency type)
			if = {
				limit = {
					exists = scope:chosen_successor
					scope:chosen_successor = { is_alive = yes }
					exists = scope:actor
					# Puppet-master diarch must be a valid courtier-type character (not a ruler)
					scope:actor = { is_alive = yes NOT = { is_ruler = yes } }
				}
				# If no active diarchy exists yet on the chosen_successor, try to start one
				if = {
					limit = { NOT = { scope:chosen_successor = { has_active_diarchy = yes } } }
					scope:chosen_successor = { try_start_diarchy = puppet_regency }
				}
				# Only set diarch/diarchy fields if an active diarchy now exists
				if = {
					limit = { scope:chosen_successor = { has_active_diarchy = yes } }
					# Ensure the diarch is in the new liege's court before setting them as diarch
					scope:actor = {
						if = { limit = { NOT = { employer = scope:chosen_successor } } set_employer = scope:chosen_successor }
					}
					scope:chosen_successor = {
						set_diarch = scope:actor
						set_diarchy_type = puppet_regency
						set_diarchy_swing = 90
					}
				}
			}
		}
	}
}
