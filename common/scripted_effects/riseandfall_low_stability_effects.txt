##########################
# Rise and Fall - Low Stability yearly roll
# Runs once per year from an on_action. For each ruler, compute chance = (100 - stability_score) * 0.05 (capped at 5%).
# If the random check succeeds, trigger an event (riseandfall.1001 - warlord).

riseandfall_low_stability_roll_se = {
    # For every independent ruler, compute chance once using the ruler's stability
        # Perform computations inside the saved scope so scope:independent_ruler variables resolve correctly
        scope:ruler_low_stability = {
            # Ensure a default stability score exists so scripts don't error when it's missing
            if = { limit = { NOT = { has_variable = riseandfall_realm_stability_score } } set_variable = { name = riseandfall_realm_stability_score value = 50 } }
            if = {
                limit = { NOT = { has_variable = low_stability_cooldown } }
                # Compute chance with a curved (approx power 1.5) formula based on highest held title tier.
                # Thresholds: county = 30, duchy = 35, kingdom = 40, empire = 45, hegemony = 50.
                # Approach: tmp_diff = max(0, threshold - stability_score)
                # Chance ~= floor( (tmp_diff^2 * 100) / (threshold^2) ); minimum 1% when tmp_diff > 0.
                set_variable = { name = stability_threshold value = 30 }
                if = { limit = { highest_held_title_tier >= tier_duchy } set_variable = { name = stability_threshold value = 35 } }
                if = { limit = { highest_held_title_tier >= tier_kingdom } set_variable = { name = stability_threshold value = 40 } }
                if = { limit = { highest_held_title_tier >= tier_empire } set_variable = { name = stability_threshold value = 45 } }
                if = { limit = { highest_held_title_tier >= tier_hegemony } set_variable = { name = stability_threshold value = 50 } }

                set_variable = { name = tmp_diff value = 0 }
                change_variable = { name = tmp_diff add = var:riseandfall_realm_stability_score }
                change_variable = { name = tmp_diff multiply = -1 }
                change_variable = { name = tmp_diff add = var:stability_threshold }
                clamp_variable = { name = tmp_diff min = 0 max = 50 }

                set_variable = { name = tmp_chance value = 0 }
                # If stability > threshold, chance should be 0%
                if = {
                    limit = { var:riseandfall_realm_stability_score > var:stability_threshold }
                    set_variable = { name = tmp_chance value = 0 }
                }
                else = {
                    # tmp_sq = tmp_diff^2
                    set_variable = { name = tmp_sq value = var:tmp_diff }
                    change_variable = { name = tmp_sq multiply = var:tmp_diff }

                    # Scale to percentage: (tmp_sq * 100) / (threshold^2)
                    set_variable = { name = tmp_chance value = var:tmp_sq }
                    change_variable = { name = tmp_chance multiply = 100 }
                    change_variable = { name = tmp_chance divide = var:stability_threshold }
                    change_variable = { name = tmp_chance divide = var:stability_threshold }

                    # Ensure at least 1% when tmp_diff > 0
                    if = { limit = { AND = { var:tmp_diff > 0 var:tmp_chance < 1 } } set_variable = { name = tmp_chance value = 1 } }
                }

                # Dynamic Story Mode: Very large and massive realms get stronger minimum chances
                if = {
                    limit = { has_variable = riseandfall_massive_realm }
                    if = { limit = { var:tmp_chance < 3 } set_variable = { name = tmp_chance value = 3 } }
                }
                else_if = {
                    limit = { has_variable = riseandfall_very_large_realm }
                    if = { limit = { var:tmp_chance < 2 } set_variable = { name = tmp_chance value = 2 } }
                }
                else_if = {
                    limit = { has_variable = riseandfall_large_realm }
                    if = { limit = { var:tmp_chance < 1 } set_variable = { name = tmp_chance value = 1 } }
                }

                # Store the calculated chance on the character for tooltip display (persists until next yearly update)
                set_variable = { name = riseandfall_low_stability_chance value = var:tmp_chance }

                # Roll once for the independent ruler. If it succeeds, notify the liege and add stability
                random = {
                    chance = var:tmp_chance
                    # Trigger a random low stability event
                    riseandfall_low_stability_random_event = yes
                }
            }
            else = {
                # If on cooldown, chance is 0
                set_variable = { name = riseandfall_low_stability_chance value = 0 }
            }
        }
    }

##########################
# Rise and Fall - Low Stability Random Event Selector
# Randomly selects between warlord uprising, peasant unrest, and puppet master offer

riseandfall_low_stability_random_event = {
    # Prefilter eligibility into simple flags to guarantee a fallback without chained logic.
    # rf_puppet_ok = 1 if puppet event is allowed (no existing puppet_regency)
    # rf_adventurer_ok = 1 if adventurer event is allowed (empire-tier ruler)
    # rf_realm_split_ok = 1 if realm split is allowed (kingdom+ ruler with 2+ powerful vassals)
    set_variable = { name = rf_puppet_ok value = 1 days = 14 }
    if = { limit = { has_diarchy_type = puppet_regency } set_variable = { name = rf_puppet_ok value = 0 days = 14 } }

    # Adventurer event retired
    # Allow adventurer invasion for kingdom-tier rulers or higher (requires highest-held title >= kingdom)
    # Also ensure the current ruler is not themselves an adventurer (avoid self-spawning adventurer events)
    # if = { limit = { AND = { highest_held_title_tier >= tier_kingdom NOT = { has_trait = adventurer } } } set_variable = { name = rf_adventurer_ok value = 1 days = 14 } }

    # Realm split eligibility: use shared trigger for consistent rules (kingdom+ and 2+ vassals, low stability)
    set_variable = { name = rf_realm_split_ok value = 0 days = 14 }
    if = {
        limit = { riseandfall_can_realm_split_trigger = yes }
        set_variable = { name = rf_realm_split_ok value = 1 days = 14 }
    }

    # Palace coup not possible for theocracies or republics
    set_variable = { name = rf_palace_coup_ok value = 1 days = 14 }
    if = { limit = { government_has_flag = government_is_theocracy } set_variable = { name = rf_palace_coup_ok value = 0 days = 14 } }
    if = { limit = { government_has_flag = government_is_republic } set_variable = { name = rf_palace_coup_ok value = 0 days = 14 } }

    # Handle all eligibility combinations with realm split as a rare but impactful option
    if = {
        limit = { AND = { var:rf_realm_split_ok = 1 var:rf_puppet_ok = 1 } }
        # All options available including realm split (rare weight)
        if = { limit = { var:rf_palace_coup_ok = 1 }
            random_list = {
                1 = { trigger_event = { id = warlord.1001 } }
                1 = { trigger_event = { id = palace_coup.1001 } }
                1 = { trigger_event = { id = realm_split.1001 } }
            }
        }
        else = {
            random_list = {
                1 = { trigger_event = { id = warlord.1001 } }
                1 = { trigger_event = { id = realm_split.1001 } }
            }
        }
    }
    else_if = {
        limit = { AND = { var:rf_realm_split_ok = 1 var:rf_puppet_ok = 0 var:rf_adventurer_ok = 1 } }
        # Realm split + adventurer allowed
        if = { limit = { var:rf_palace_coup_ok = 1 }
            random_list = {
                1 = { trigger_event = { id = warlord.1001 } }
                1 = { trigger_event = { id = palace_coup.1001 } }
                1 = { trigger_event = { id = realm_split.1001 } }
            }
        }
        else = {
            random_list = {
                1 = { trigger_event = { id = warlord.1001 } }
                1 = { trigger_event = { id = realm_split.1001 } }
            }
        }
    }
    else_if = {
        limit = { AND = { var:rf_realm_split_ok = 1 var:rf_puppet_ok = 0 } }
        # Only realm split from special options
        if = { limit = { var:rf_palace_coup_ok = 1 }
            random_list = {
                1 = { trigger_event = { id = warlord.1001 } }
                1 = { trigger_event = { id = palace_coup.1001 } }
                1 = { trigger_event = { id = realm_split.1001 } }
            }
        }
        else = {
            random_list = {
                1 = { trigger_event = { id = warlord.1001 } }
                1 = { trigger_event = { id = realm_split.1001 } }
            }
        }
    }
    else_if = {
        limit = { var:rf_puppet_ok = 1 }
        # Only puppet allowed
        random_list = {
            1 = { trigger_event = { id = warlord.1001 } }
            1 = { trigger_event = { id = palace_coup.1001 } }
        }
    }
    else = {
        # Neither allowed: fallback to warlord / palace coup
        if = { limit = { var:rf_palace_coup_ok = 1 }
            random_list = {
                1 = { trigger_event = { id = warlord.1001 } }
                1 = { trigger_event = { id = palace_coup.1001 } }
            }
        }
        else = {
            random_list = {
                1 = { trigger_event = { id = warlord.1001 } }
            }
        }
    }
}